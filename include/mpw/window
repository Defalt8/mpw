#pragma once
#ifndef MPW_WINDOW
#define MPW_WINDOW

#ifndef _WIN32
#include <ds/unordered_map>
#endif
#include <ds/callable>
#include "common"
#include "enums"
#include "display"
#include "event"
#include "window"

#ifdef _WIN32
	struct HMODULE__;
	struct HWND__;
	struct HGLRC__;
	struct HDC__;
	struct HINSTANCE__;
	struct HICON__;
	struct HCURSOR__;
	struct HBRUSH__;
	struct HMENU__;
	struct HCURSOR__;
	struct HICON__;
#else
	struct GLXContext_;
#endif

namespace mw {

#ifdef _WIN32
#	if defined(_DLL)
#		define MPW_WINAPI extern "C" __declspec(dllimport)
#	else
#		define MPW_WINAPI extern "C"
#	endif

namespace _win {

  #if defined(_WIN64)
    using INT_PTR   = long long;
    using UINT_PTR  = unsigned long long;
    using LONG_PTR  = long long;
    using ULONG_PTR = unsigned long long;
  #else
    using INT_PTR   = int;
    using UINT_PTR  = unsigned int;
    using LONG_PTR  = long;
    using ULONG_PTR = unsigned long;
  #endif
	using BOOL      = int;
	using BYTE      = unsigned char;
	using WORD      = unsigned short;
	using CHAR      = char;
	using SHORT     = short;
	using USHORT    = unsigned short;
	using LONG      = long;
	using INT       = int;
	using UINT      = unsigned int;
	using DWORD     = unsigned long;
	using ATOM      = WORD;
	using LONG      = long;
	using WPARAM    = UINT_PTR;
	using LPARAM    = LONG_PTR;
	using LRESULT   = LONG_PTR;
	using LPCSTR    = char const *;
	using HANDLE    = void *;
	using HMODULE   = HMODULE__ *;
	using HWND      = HWND__ *;
	using HGLRC     = HGLRC__ *;
	using HDC       = HDC__ *;
	using HINSTANCE = HINSTANCE__ *;
	using HICON     = HICON__ *;
	using HCURSOR   = HCURSOR__ *;
	using HBRUSH    = HBRUSH__ *;
	using HMENU     = HMENU__ *;
	using HCURSOR   = HCURSOR__ *;
	using HICON     = HICON__ *;
	using FARPROC   = INT_PTR (__stdcall *)(); 
	using PROC      = INT_PTR (__stdcall *)(); 
	using WNDPROC   = LRESULT (__stdcall *)(HWND, UINT, WPARAM, LPARAM);

	struct POINT 
	{
		LONG x;
		LONG y;
	};

	struct RECT
	{
		LONG left;
		LONG top;
		LONG right;
		LONG bottom;
	};

	struct WNDCLASSEXA 
	{
		UINT        cbSize;
		UINT        style;
		WNDPROC     lpfnWndProc;
		int         cbClsExtra;
		int         cbWndExtra;
		HINSTANCE   hInstance;
		HICON       hIcon;
		HCURSOR     hCursor;
		HBRUSH      hbrBackground;
		LPCSTR      lpszMenuName;
		LPCSTR      lpszClassName;
		HICON       hIconSm;
	};

	struct PIXELFORMATDESCRIPTOR
	{
		WORD  nSize;
		WORD  nVersion;
		DWORD dwFlags;
		BYTE  iPixelType;
		BYTE  cColorBits;
		BYTE  cRedBits;
		BYTE  cRedShift;
		BYTE  cGreenBits;
		BYTE  cGreenShift;
		BYTE  cBlueBits;
		BYTE  cBlueShift;
		BYTE  cAlphaBits;
		BYTE  cAlphaShift;
		BYTE  cAccumBits;
		BYTE  cAccumRedBits;
		BYTE  cAccumGreenBits;
		BYTE  cAccumBlueBits;
		BYTE  cAccumAlphaBits;
		BYTE  cDepthBits;
		BYTE  cStencilBits;
		BYTE  cAuxBuffers;
		BYTE  iLayerType;
		BYTE  bReserved;
		DWORD dwLayerMask;
		DWORD dwVisibleMask;
		DWORD dwDamageMask;
	};
		
	struct MSG 
	{
		HWND        hwnd;
		UINT        message;
		WPARAM      wParam;
		LPARAM      lParam;
		DWORD       time;
		POINT       pt;
	};

	struct MINMAXINFO 
	{
		POINT ptReserved;
		POINT ptMaxSize;
		POINT ptMaxPosition;
		POINT ptMinTrackSize;
		POINT ptMaxTrackSize;
	};

	static constexpr  int   CW_USEDEFAULT_             = ((int)0x80000000);
	static constexpr  DWORD CS_OWNDC_                  = 0x0020;
	static constexpr  DWORD COLOR_WINDOW_              = 5;
	static constexpr  BYTE  PFD_TYPE_RGBA_             = 0;
	static constexpr  BYTE  PFD_TYPE_COLORINDEX_       = 1;
	static constexpr  BYTE  PFD_MAIN_PLANE_            = 0;
	static constexpr  BYTE  PFD_OVERLAY_PLANE_         = 1;
	static constexpr  BYTE  PFD_UNDERLAY_PLANE_        = BYTE(-1);
	static constexpr  DWORD PFD_DOUBLEBUFFER_          = 0x00000001;
	static constexpr  DWORD PFD_STEREO_                = 0x00000002;
	static constexpr  DWORD PFD_DRAW_TO_WINDOW_        = 0x00000004;
	static constexpr  DWORD PFD_DRAW_TO_BITMAP_        = 0x00000008;
	static constexpr  DWORD PFD_SUPPORT_GDI_           = 0x00000010;
	static constexpr  DWORD PFD_SUPPORT_OPENGL_        = 0x00000020;
	static constexpr  DWORD PFD_GENERIC_FORMAT_        = 0x00000040;
	static constexpr  DWORD PFD_NEED_PALETTE_          = 0x00000080;
	static constexpr  DWORD PFD_NEED_SYSTEM_PALETTE_   = 0x00000100;
	static constexpr  DWORD PFD_SWAP_EXCHANGE_         = 0x00000200;
	static constexpr  DWORD PFD_SWAP_COPY_             = 0x00000400;
	static constexpr  DWORD PFD_SWAP_LAYER_BUFFERS_    = 0x00000800;
	static constexpr  DWORD PFD_GENERIC_ACCELERATED_   = 0x00001000;
	static constexpr  DWORD PFD_SUPPORT_DIRECTDRAW_    = 0x00002000;
	static constexpr  DWORD PFD_DIRECT3D_ACCELERATED_  = 0x00004000;
	static constexpr  DWORD PFD_SUPPORT_COMPOSITION_   = 0x00008000;
	static constexpr  DWORD PFD_DEPTH_DONTCARE_        = 0x20000000;
	static constexpr  DWORD PFD_DOUBLEBUFFER_DONTCARE_ = 0x40000000;
	static constexpr  DWORD PFD_STEREO_DONTCARE_       = 0x80000000;

	static constexpr  WORD  SWP_NOSIZE_          = 0x0001;
	static constexpr  WORD  SWP_NOMOVE_          = 0x0002;
	static constexpr  WORD  SWP_NOZORDER_        = 0x0004;
	static constexpr  WORD  SWP_NOREDRAW_        = 0x0008;
	static constexpr  WORD  SWP_NOACTIVATE_      = 0x0010;
	static constexpr  WORD  SWP_FRAMECHANGED_    = 0x0020;
	static constexpr  WORD  SWP_SHOWWINDOW_      = 0x0040;
	static constexpr  WORD  SWP_HIDEWINDOW_      = 0x0080;
	static constexpr  WORD  SWP_NOCOPYBITS_      = 0x0100;
	static constexpr  WORD  SWP_NOOWNERZORDER_   = 0x0200;
	static constexpr  WORD  SWP_NOSENDCHANGING_  = 0x0400;
	static constexpr  WORD  SWP_DRAWFRAME_       = SWP_FRAMECHANGED_;
	static constexpr  WORD  SWP_NOREPOSITION_    = SWP_NOOWNERZORDER_;

	static constexpr  DWORD SIZE_RESTORED_       = 0;
	static constexpr  DWORD SIZE_MINIMIZED_      = 1;
	static constexpr  DWORD SIZE_MAXIMIZED_      = 2;
	static constexpr  DWORD SIZE_MAXSHOW_        = 3;
	static constexpr  DWORD SIZE_MAXHIDE_        = 4;
	static constexpr  DWORD WS_OVERLAPPED_        = 0x00000000L;
	static constexpr  DWORD WS_POPUP_             = 0x80000000L;
	static constexpr  DWORD WS_CHILD_             = 0x40000000L;
	static constexpr  DWORD WS_MINIMIZE_          = 0x20000000L;
	static constexpr  DWORD WS_VISIBLE_           = 0x10000000L;
	static constexpr  DWORD WS_DISABLED_          = 0x08000000L;
	static constexpr  DWORD WS_CLIPSIBLINGS_      = 0x04000000L;
	static constexpr  DWORD WS_CLIPCHILDREN_      = 0x02000000L;
	static constexpr  DWORD WS_MAXIMIZE_          = 0x01000000L;
	static constexpr  DWORD WS_CAPTION_           = 0x00C00000L;
	static constexpr  DWORD WS_BORDER_            = 0x00800000L;
	static constexpr  DWORD WS_DLGFRAME_          = 0x00400000L;
	static constexpr  DWORD WS_VSCROLL_           = 0x00200000L;
	static constexpr  DWORD WS_HSCROLL_           = 0x00100000L;
	static constexpr  DWORD WS_SYSMENU_           = 0x00080000L;
	static constexpr  DWORD WS_THICKFRAME_        = 0x00040000L;
	static constexpr  DWORD WS_GROUP_             = 0x00020000L;
	static constexpr  DWORD WS_TABSTOP_           = 0x00010000L;
	static constexpr  DWORD WS_MINIMIZEBOX_       = 0x00020000L;
	static constexpr  DWORD WS_MAXIMIZEBOX_       = 0x00010000L;
	static constexpr  DWORD WS_TILED_             = WS_OVERLAPPED_;
	static constexpr  DWORD WS_ICONIC_            = WS_MINIMIZE_;
	static constexpr  DWORD WS_SIZEBOX_           = WS_THICKFRAME_;
	static constexpr  DWORD WS_OVERLAPPEDWINDOW_  =
		  WS_OVERLAPPED_
		| WS_CAPTION_
		| WS_SYSMENU_
		| WS_THICKFRAME_
		| WS_MINIMIZEBOX_
		| WS_MAXIMIZEBOX_;
	static constexpr  DWORD WS_POPUPWINDOW_       = 
		  WS_POPUP_
        | WS_BORDER_
        | WS_SYSMENU_;
	static constexpr  DWORD WS_TILEDWINDOW_       = WS_OVERLAPPEDWINDOW_;
	static constexpr  DWORD PM_NOREMOVE_          = 0x0000;
	static constexpr  DWORD PM_REMOVE_            = 0x0001;
	static constexpr  DWORD PM_NOYIELD_           = 0x0002;
	static constexpr  DWORD WM_NULL_              = 0x0000;
	static constexpr  DWORD WM_CREATE_            = 0x0001;
	static constexpr  DWORD WM_DESTROY_           = 0x0002;
	static constexpr  DWORD WM_MOVE_              = 0x0003;
	static constexpr  DWORD WM_SIZE_              = 0x0005;
	static constexpr  DWORD WM_ACTIVATE_          = 0x0006;
	static constexpr  DWORD WA_INACTIVE_          = 0;
	static constexpr  DWORD WA_ACTIVE_            = 1;
	static constexpr  DWORD WA_CLICKACTIVE_       = 2;
	static constexpr  DWORD WM_SETFOCUS_          = 0x0007;
	static constexpr  DWORD WM_KILLFOCUS_         = 0x0008;
	static constexpr  DWORD WM_ENABLE_            = 0x000A;
	static constexpr  DWORD WM_SETREDRAW_         = 0x000B;
	static constexpr  DWORD WM_SETTEXT_           = 0x000C;
	static constexpr  DWORD WM_GETTEXT_           = 0x000D;
	static constexpr  DWORD WM_GETTEXTLENGTH_     = 0x000E;
	static constexpr  DWORD WM_PAINT_             = 0x000F;
	static constexpr  DWORD WM_CLOSE_             = 0x0010;
	static constexpr  DWORD WM_QUIT_              = 0x0012;
	static constexpr  DWORD WM_ERASEBKGND_        = 0x0014;
	static constexpr  DWORD WM_SYSCOLORCHANGE_    = 0x0015;
	static constexpr  DWORD WM_SHOWWINDOW_        = 0x0018;
	static constexpr  DWORD WM_WININICHANGE_      = 0x001A;
	static constexpr  DWORD WM_DEVMODECHANGE_     = 0x001B;
	static constexpr  DWORD WM_ACTIVATEAPP_       = 0x001C;
	static constexpr  DWORD WM_FONTCHANGE_        = 0x001D;
	static constexpr  DWORD WM_TIMECHANGE_        = 0x001E;
	static constexpr  DWORD WM_CANCELMODE_        = 0x001F;
	static constexpr  DWORD WM_SETCURSOR_         = 0x0020;
	static constexpr  DWORD WM_MOUSEACTIVATE_     = 0x0021;
	static constexpr  DWORD WM_CHILDACTIVATE_     = 0x0022;
	static constexpr  DWORD WM_QUEUESYNC_         = 0x0023;
	static constexpr  DWORD WM_GETMINMAXINFO_     = 0x0024;
	static constexpr  DWORD WM_PAINTICON_         = 0x0026;
	static constexpr  DWORD WM_ICONERASEBKGND_    = 0x0027;
	static constexpr  DWORD WM_NEXTDLGCTL_        = 0x0028;
	static constexpr  DWORD WM_SPOOLERSTATUS_     = 0x002A;
	static constexpr  DWORD WM_DRAWITEM_          = 0x002B;
	static constexpr  DWORD WM_MEASUREITEM_       = 0x002C;
	static constexpr  DWORD WM_DELETEITEM_        = 0x002D;
	static constexpr  DWORD WM_VKEYTOITEM_        = 0x002E;
	static constexpr  DWORD WM_CHARTOITEM_        = 0x002F;
	static constexpr  DWORD WM_SETFONT_           = 0x0030;
	static constexpr  DWORD WM_GETFONT_           = 0x0031;
	static constexpr  DWORD WM_SETHOTKEY_         = 0x0032;
	static constexpr  DWORD WM_GETHOTKEY_         = 0x0033;
	static constexpr  DWORD WM_QUERYDRAGICON_     = 0x0037;
	static constexpr  DWORD WM_COMPAREITEM_       = 0x0039;
	static constexpr  DWORD WM_COMPACTING_        = 0x0041;
	static constexpr  DWORD WM_WINDOWPOSCHANGING_ = 0x0046;
	static constexpr  DWORD WM_WINDOWPOSCHANGED_  = 0x0047;
	static constexpr  DWORD WM_NCCREATE_          = 0x0081;
	static constexpr  DWORD WM_NCDESTROY_         = 0x0082;
	static constexpr  DWORD WM_NCCALCSIZE_        = 0x0083;
	static constexpr  DWORD WM_NCHITTEST_         = 0x0084;
	static constexpr  DWORD WM_NCPAINT_           = 0x0085;
	static constexpr  DWORD WM_NCACTIVATE_        = 0x0086;
	static constexpr  DWORD WM_GETDLGCODE_        = 0x0087;
	static constexpr  DWORD WM_NCMOUSEMOVE_       = 0x00A0;
	static constexpr  DWORD WM_NCLBUTTONDOWN_     = 0x00A1;
	static constexpr  DWORD WM_NCLBUTTONUP_       = 0x00A2;
	static constexpr  DWORD WM_NCLBUTTONDBLCLK_   = 0x00A3;
	static constexpr  DWORD WM_NCRBUTTONDOWN_     = 0x00A4;
	static constexpr  DWORD WM_NCRBUTTONUP_       = 0x00A5;
	static constexpr  DWORD WM_NCRBUTTONDBLCLK_   = 0x00A6;
	static constexpr  DWORD WM_NCMBUTTONDOWN_     = 0x00A7;
	static constexpr  DWORD WM_NCMBUTTONUP_       = 0x00A8;
	static constexpr  DWORD WM_NCMBUTTONDBLCLK_   = 0x00A9;
	static constexpr  DWORD WM_KEYFIRST_          = 0x0100;
	static constexpr  DWORD WM_KEYDOWN_           = 0x0100;
	static constexpr  DWORD WM_KEYUP_             = 0x0101;
	static constexpr  DWORD WM_CHAR_              = 0x0102;
	static constexpr  DWORD WM_DEADCHAR_          = 0x0103;
	static constexpr  DWORD WM_SYSKEYDOWN_        = 0x0104;
	static constexpr  DWORD WM_SYSKEYUP_          = 0x0105;
	static constexpr  DWORD WM_SYSCHAR_           = 0x0106;
	static constexpr  DWORD WM_SYSDEADCHAR_       = 0x0107;
	static constexpr  DWORD WM_INITDIALOG_        = 0x0110;
	static constexpr  DWORD WM_COMMAND_           = 0x0111;
	static constexpr  DWORD WM_SYSCOMMAND_        = 0x0112;
	static constexpr  DWORD WM_TIMER_             = 0x0113;
	static constexpr  DWORD WM_HSCROLL_           = 0x0114;
	static constexpr  DWORD WM_VSCROLL_           = 0x0115;
	static constexpr  DWORD WM_INITMENU_          = 0x0116;
	static constexpr  DWORD WM_INITMENUPOPUP_     = 0x0117;
	static constexpr  DWORD WM_MOUSEFIRST_        = 0x0200;
	static constexpr  DWORD WM_MOUSEMOVE_         = 0x0200;
	static constexpr  DWORD WM_LBUTTONDOWN_       = 0x0201;
	static constexpr  DWORD WM_LBUTTONUP_         = 0x0202;
	static constexpr  DWORD WM_LBUTTONDBLCLK_     = 0x0203;
	static constexpr  DWORD WM_RBUTTONDOWN_       = 0x0204;
	static constexpr  DWORD WM_RBUTTONUP_         = 0x0205;
	static constexpr  DWORD WM_RBUTTONDBLCLK_     = 0x0206;
	static constexpr  DWORD WM_MBUTTONDOWN_       = 0x0207;
	static constexpr  DWORD WM_MBUTTONUP_         = 0x0208;
	static constexpr  DWORD WM_MBUTTONDBLCLK_     = 0x0209;
	static constexpr  DWORD WM_MOUSEHWHEEL_       = 0x020E;
	static constexpr  DWORD WM_MOUSEWHEEL_        = 0x020A;
	static constexpr  DWORD WM_XBUTTONDOWN_       = 0x020B;
	static constexpr  DWORD WM_XBUTTONUP_         = 0x020C;
	static constexpr  DWORD WM_XBUTTONDBLCLK_     = 0x020D;
	static constexpr  WORD  IDC_ARROW_            = 32512;
	static constexpr  WORD  IDC_IBEAM_            = 32513;
	static constexpr  WORD  IDC_WAIT_             = 32514;
	static constexpr  WORD  IDC_CROSS_            = 32515;
	static constexpr  WORD  IDC_UPARROW_          = 32516;
	static constexpr  WORD  IDC_SIZE_             = 32640;
	static constexpr  WORD  IDC_ICON_             = 32641;
	static constexpr  WORD  IDC_SIZENWSE_         = 32642;
	static constexpr  WORD  IDC_SIZENESW_         = 32643;
	static constexpr  WORD  IDC_SIZEWE_           = 32644;
	static constexpr  WORD  IDC_SIZENS_           = 32645;
	static constexpr  WORD  IDC_SIZEALL_          = 32646;
	static constexpr  WORD  IDC_NO_               = 32648;
	static constexpr  WORD  IDI_APPLICATION_      = 32512;
	static constexpr  WORD  IDI_HAND_             = 32513;
	static constexpr  WORD  IDI_QUESTION_         = 32514;
	static constexpr  WORD  IDI_EXCLAMATION_      = 32515;
	static constexpr  WORD  IDI_ASTERISK_         = 32516;
	static constexpr  int   GWL_WNDPROC_          = -4;
	static constexpr  int   GWL_HINSTANCE_        = -6;
	static constexpr  int   GWL_HWNDPARENT_       = -8;
	static constexpr  int   GWL_STYLE_            = -16;
	static constexpr  int   GWL_EXSTYLE_          = -20;
	static constexpr  int   GWL_USERDATA_         = -21;
	static constexpr  int   GWL_ID_               = -12;
	static constexpr  int   GWLP_WNDPROC_         = -4;
	static constexpr  int   GWLP_HINSTANCE_       = -6;
	static constexpr  int   GWLP_HWNDPARENT_      = -8;
	static constexpr  int   GWLP_USERDATA_        = -21;
	static constexpr  int   GWLP_ID_              = -12;
	static constexpr  int   SW_HIDE_              = 0;
	static constexpr  int   SW_SHOWNORMAL_        = 1;
	static constexpr  int   SW_NORMAL_            = 1;
	static constexpr  int   SW_SHOWMINIMIZED_     = 2;
	static constexpr  int   SW_SHOWMAXIMIZED_     = 3;
	static constexpr  int   SW_MAXIMIZE_          = 3;
	static constexpr  int   SW_SHOWNOACTIVATE_    = 4;
	static constexpr  int   SW_SHOW_              = 5;
	static constexpr  int   SW_MINIMIZE_          = 6;
	static constexpr  int   SW_SHOWMINNOACTIVE_   = 7;
	static constexpr  int   SW_SHOWNA_            = 8;
	static constexpr  int   SW_RESTORE_           = 9;
	static constexpr  int   SW_SHOWDEFAULT_       = 10;
	static constexpr  int   SW_FORCEMINIMIZE_     = 11;
	static constexpr  int   SW_MAX_               = 11;

	static constexpr  DWORD VK_CANCEL_            = 0x03;
	static constexpr  DWORD VK_BACK_              = 0x08;
	static constexpr  DWORD VK_TAB_               = 0x09;
	static constexpr  DWORD VK_CLEAR_             = 0x0C;
	static constexpr  DWORD VK_RETURN_            = 0x0D;
	static constexpr  DWORD VK_SHIFT_             = 0x10;
	static constexpr  DWORD VK_CONTROL_           = 0x11;
	static constexpr  DWORD VK_MENU_              = 0x12;
	static constexpr  DWORD VK_PAUSE_             = 0x13;
	static constexpr  DWORD VK_CAPITAL_           = 0x14;
	static constexpr  DWORD VK_ESCAPE_            = 0x1B;
	static constexpr  DWORD VK_SPACE_             = 0x20;
	static constexpr  DWORD VK_PRIOR_             = 0x21;
	static constexpr  DWORD VK_NEXT_              = 0x22;
	static constexpr  DWORD VK_END_               = 0x23;
	static constexpr  DWORD VK_HOME_              = 0x24;
	static constexpr  DWORD VK_LEFT_              = 0x25;
	static constexpr  DWORD VK_UP_                = 0x26;
	static constexpr  DWORD VK_RIGHT_             = 0x27;
	static constexpr  DWORD VK_DOWN_              = 0x28;
	static constexpr  DWORD VK_SELECT_            = 0x29;
	static constexpr  DWORD VK_EXECUTE_           = 0x2B;
	static constexpr  DWORD VK_SNAPSHOT_          = 0x2C;
	static constexpr  DWORD VK_INSERT_            = 0x2D;
	static constexpr  DWORD VK_DELETE_            = 0x2E;
	static constexpr  DWORD VK_HELP_              = 0x2F;
	static constexpr  DWORD VK_LWIN_              = 0x5B;
	static constexpr  DWORD VK_RWIN_              = 0x5C;
	static constexpr  DWORD VK_APPS_              = 0x5D;
	static constexpr  DWORD VK_NUMPAD0_           = 0x60;
	static constexpr  DWORD VK_NUMPAD1_           = 0x61;
	static constexpr  DWORD VK_NUMPAD2_           = 0x62;
	static constexpr  DWORD VK_NUMPAD3_           = 0x63;
	static constexpr  DWORD VK_NUMPAD4_           = 0x64;
	static constexpr  DWORD VK_NUMPAD5_           = 0x65;
	static constexpr  DWORD VK_NUMPAD6_           = 0x66;
	static constexpr  DWORD VK_NUMPAD7_           = 0x67;
	static constexpr  DWORD VK_NUMPAD8_           = 0x68;
	static constexpr  DWORD VK_NUMPAD9_           = 0x69;
	static constexpr  DWORD VK_MULTIPLY_          = 0x6A;
	static constexpr  DWORD VK_ADD_               = 0x6B;
	static constexpr  DWORD VK_SEPARATOR_         = 0x6C;
	static constexpr  DWORD VK_SUBTRACT_          = 0x6D;
	static constexpr  DWORD VK_DECIMAL_           = 0x6E;
	static constexpr  DWORD VK_DIVIDE_            = 0x6F;
	static constexpr  DWORD VK_F1_                = 0x70;
	static constexpr  DWORD VK_F2_                = 0x71;
	static constexpr  DWORD VK_F3_                = 0x72;
	static constexpr  DWORD VK_F4_                = 0x73;
	static constexpr  DWORD VK_F5_                = 0x74;
	static constexpr  DWORD VK_F6_                = 0x75;
	static constexpr  DWORD VK_F7_                = 0x76;
	static constexpr  DWORD VK_F8_                = 0x77;
	static constexpr  DWORD VK_F9_                = 0x78;
	static constexpr  DWORD VK_F10_               = 0x79;
	static constexpr  DWORD VK_F11_               = 0x7A;
	static constexpr  DWORD VK_F12_               = 0x7B;
	static constexpr  DWORD VK_F13_               = 0x7C;
	static constexpr  DWORD VK_F14_               = 0x7D;
	static constexpr  DWORD VK_F15_               = 0x7E;
	static constexpr  DWORD VK_F16_               = 0x7F;
	static constexpr  DWORD VK_F17_               = 0x80;
	static constexpr  DWORD VK_F18_               = 0x81;
	static constexpr  DWORD VK_F19_               = 0x82;
	static constexpr  DWORD VK_F20_               = 0x83;
	static constexpr  DWORD VK_F21_               = 0x84;
	static constexpr  DWORD VK_F22_               = 0x85;
	static constexpr  DWORD VK_F23_               = 0x86;
	static constexpr  DWORD VK_F24_               = 0x87;
	static constexpr  DWORD VK_NUMLOCK_           = 0x90;
	static constexpr  DWORD VK_SCROLL_            = 0x91;
	static constexpr  DWORD VK_LSHIFT_            = 0xA0;
	static constexpr  DWORD VK_RSHIFT_            = 0xA1;
	static constexpr  DWORD VK_LCONTROL_          = 0xA2;
	static constexpr  DWORD VK_RCONTROL_          = 0xA3;
	static constexpr  DWORD VK_LMENU_             = 0xA4;
	static constexpr  DWORD VK_RMENU_             = 0xA5;
	static constexpr  UINT  MAPVK_VK_TO_VSC_      = 0;
	static constexpr  UINT  MAPVK_VSC_TO_VK_      = 1;
	static constexpr  UINT  MAPVK_VK_TO_CHAR_     = 2;
	static constexpr  UINT  MAPVK_VSC_TO_VK_EX_   = 3;

	static inline WORD _loword(DWORD dw) noexcept { return (dw & 0x0000FFFF); }
	static inline WORD _hiword(DWORD dw) noexcept { return (dw & 0xFFFF0000) >> 16; }

	MPW_WINAPI HMODULE  __stdcall LoadLibraryA(LPCSTR);
	MPW_WINAPI BOOL     __stdcall FreeLibrary(HMODULE);
	MPW_WINAPI FARPROC  __stdcall GetProcAddress(HMODULE, LPCSTR);
	MPW_WINAPI BOOL     __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
	MPW_WINAPI HGLRC    __stdcall wglCreateContext(HDC);
	MPW_WINAPI HGLRC    __stdcall wglCreateLayerContext(HDC, int);
	MPW_WINAPI BOOL     __stdcall wglDeleteContext(HGLRC);
	MPW_WINAPI HGLRC    __stdcall wglGetCurrentContext(void);
	MPW_WINAPI HDC      __stdcall wglGetCurrentDC(void);
	MPW_WINAPI PROC     __stdcall wglGetProcAddress(LPCSTR);
	MPW_WINAPI BOOL     __stdcall wglMakeCurrent(HDC, HGLRC);
	MPW_WINAPI BOOL     __stdcall wglShareLists(HGLRC, HGLRC);
	MPW_WINAPI ATOM     __stdcall RegisterClassExA(WNDCLASSEXA const *);
	MPW_WINAPI HMODULE  __stdcall GetModuleHandleA(LPCSTR);
	MPW_WINAPI LRESULT  __stdcall DefWindowProcA(HWND, UINT, WPARAM, LPARAM);
	MPW_WINAPI HWND     __stdcall CreateWindowExA(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void * param);
	MPW_WINAPI int      __stdcall ReleaseDC(HWND, HDC);
	MPW_WINAPI BOOL     __stdcall DestroyWindow(HWND);
	MPW_WINAPI HDC      __stdcall GetDC(HWND);
	MPW_WINAPI BOOL     __stdcall SetPixelFormat(HDC, int, PIXELFORMATDESCRIPTOR const *);
	MPW_WINAPI int      __stdcall ChoosePixelFormat(HDC, PIXELFORMATDESCRIPTOR const *);
	MPW_WINAPI int      __stdcall DescribePixelFormat(HDC, int, UINT, PIXELFORMATDESCRIPTOR *);
	MPW_WINAPI LONG     __stdcall GetWindowLongA(HWND, int);
	MPW_WINAPI LONG     __stdcall SetWindowLongA(HWND, int, LONG);
  #ifdef _WIN64
	MPW_WINAPI LONG_PTR __stdcall GetWindowLongPtrA(HWND, int);
	MPW_WINAPI LONG_PTR __stdcall SetWindowLongPtrA(HWND, int, LONG_PTR);
  #else
	static inline LONG_PTR __stdcall GetWindowLongPtrA(HWND hwnd, int gwl) { return (LONG_PTR)GetWindowLongA(hwnd, gwl); }
	static inline LONG_PTR __stdcall SetWindowLongPtrA(HWND hwnd, int gwl, LONG_PTR lp) { return (LONG_PTR)SetWindowLongA(hwnd, gwl, LONG(lp)); }
  #endif
	MPW_WINAPI BOOL     __stdcall SwapBuffers(HDC);
	MPW_WINAPI BOOL     __stdcall GetMessageA(MSG *, HWND, UINT, UINT);
	MPW_WINAPI BOOL     __stdcall PeekMessageA(MSG *, HWND, UINT, UINT, UINT);
	MPW_WINAPI BOOL     __stdcall TranslateMessage(MSG const *);
	MPW_WINAPI LRESULT  __stdcall DispatchMessageA(MSG const *);
	MPW_WINAPI HCURSOR  __stdcall LoadCursorA(HINSTANCE, LPCSTR);
	MPW_WINAPI HICON    __stdcall LoadIconA(HINSTANCE, LPCSTR);
	MPW_WINAPI BOOL     __stdcall ShowWindow(HWND, int);
	MPW_WINAPI BOOL     __stdcall SetWindowPos(HWND, HWND, int, int, int, int, UINT);
	MPW_WINAPI BOOL     __stdcall AdjustWindowRectEx(RECT *, DWORD, BOOL, DWORD);
	MPW_WINAPI BOOL     __stdcall ScreenToClient(HWND, POINT *);
	MPW_WINAPI UINT     __stdcall MapVirtualKeyA(UINT, UINT);
	MPW_WINAPI SHORT    __stdcall GetKeyState(int);
	MPW_WINAPI SHORT    __stdcall GetAsyncKeyState(int);

} // namespace _win

namespace _ {

using DWORD = mw::_win::DWORD;

static key
_map_key(DWORD key_code_, DWORD scancode_ = 0)
{
	using namespace mw::_win;
	switch(key_code_)
	{
		case VK_CANCEL_:        return key_cancel;
		case VK_BACK_:          return key_backspace;
		case VK_TAB_:           return key_tab;
		case VK_CLEAR_:         return key_clear;
		case VK_RETURN_:        return (scancode_ & 0x01000000) ? key_num_enter : key_enter;
		case VK_LSHIFT_:        return key_lshift;
		case VK_RSHIFT_:        return key_rshift;
		case VK_LCONTROL_:      return key_lcontrol;
		case VK_RCONTROL_:      return key_rcontrol;
		case VK_LMENU_:         return key_lalt;
		case VK_RMENU_:         return key_ralt;
		case VK_APPS_:          return key_menu;
		case VK_LWIN_:          return key_lcommand;
		case VK_RWIN_:          return key_rcommand;
		case VK_PAUSE_:         return key_pause;
		case VK_NUMLOCK_:       return key_num_lock;
		case VK_CAPITAL_:       return key_caps_lock;
		case VK_SCROLL_:        return key_scroll_lock;
		case VK_ESCAPE_:        return key_escape;
		case VK_SPACE_:         return key_space;
		case VK_PRIOR_:         return (scancode_ & 0x01000000) ? key_page_up : key_num_page_up;
		case VK_NEXT_:          return (scancode_ & 0x01000000) ? key_page_down : key_num_page_down;
		case VK_END_:           return (scancode_ & 0x01000000) ? key_end : key_num_end;
		case VK_HOME_:          return (scancode_ & 0x01000000) ? key_home : key_num_home;
		case VK_LEFT_:          return (scancode_ & 0x01000000) ? key_left : key_num_left;
		case VK_RIGHT_:         return (scancode_ & 0x01000000) ? key_right : key_num_right;
		case VK_UP_:            return (scancode_ & 0x01000000) ? key_up : key_num_up;
		case VK_DOWN_:          return (scancode_ & 0x01000000) ? key_down : key_num_down;
		case VK_SELECT_:        return key_select;
		case VK_EXECUTE_:       return key_execute;
		case VK_SNAPSHOT_:      return key_print;
		case VK_INSERT_:        return (scancode_ & 0x01000000) ? key_insert : key_num_insert;
		case VK_DELETE_:        return (scancode_ & 0x01000000) ? key_delete : key_num_delete;
		case VK_HELP_:          return key_help;
		case VK_F1_:            return key_f1;
		case VK_F2_:            return key_f2;
		case VK_F3_:            return key_f3;
		case VK_F4_:            return key_f4;
		case VK_F5_:            return key_f5;
		case VK_F6_:            return key_f6;
		case VK_F7_:            return key_f7;
		case VK_F8_:            return key_f8;
		case VK_F9_:            return key_f9;
		case VK_F10_:           return key_f10;
		case VK_F11_:           return key_f11;
		case VK_F12_:           return key_f12;
		case VK_NUMPAD0_:       return key_num_0;
		case VK_NUMPAD1_:       return key_num_1;
		case VK_NUMPAD2_:       return key_num_2;
		case VK_NUMPAD3_:       return key_num_3;
		case VK_NUMPAD4_:       return key_num_4;
		case VK_NUMPAD5_:       return key_num_5;
		case VK_NUMPAD6_:       return key_num_6;
		case VK_NUMPAD7_:       return key_num_7;
		case VK_NUMPAD8_:       return key_num_8;
		case VK_NUMPAD9_:       return key_num_9;
		case VK_DIVIDE_:        return key_num_divide;
		case VK_MULTIPLY_:      return key_num_multiply;
		case VK_SUBTRACT_:      return key_num_subtract;
		case VK_ADD_:           return key_num_add;
		case VK_DECIMAL_:       return key_num_decimal;
		default:
		{
			UINT char_code   = MapVirtualKeyA(key_code_, MAPVK_VK_TO_CHAR_);
			bool shift_down_ = GetKeyState(VK_SHIFT_) & 0x10000000;
			switch(char_code)
			{
				case '`':  return shift_down_ ? key_tilde : key_back_tick;
				case '1':  return shift_down_ ? key_exclamation : key_minus;
				case '2':  return shift_down_ ? key_at : key_equal;
				case '3':  return shift_down_ ? key_numbersign : key_lbracket;
				case '4':  return shift_down_ ? key_dollarsign : key_rbracket;
				case '5':  return shift_down_ ? key_percent : key_back_slash;
				case '6':  return shift_down_ ? key_circumflex : key_semicolon;
				case '7':  return shift_down_ ? key_ampersand : key_quote;
				case '8':  return shift_down_ ? key_asterisk : key_comma;
				case '9':  return shift_down_ ? key_lparenthesis : key_period;
				case '0':  return shift_down_ ? key_rparenthesis : key_slash;
				case '-':  return shift_down_ ? key_underscore : key_1;
				case '=':  return shift_down_ ? key_plus : key_2;
				case '[':  return shift_down_ ? key_lbrace : key_3;
				case ']':  return shift_down_ ? key_rbrace : key_4;
				case '\\': return shift_down_ ? key_bar : key_5;
				case ';':  return shift_down_ ? key_colon : key_6;
				case '\'': return shift_down_ ? key_double_quote : key_7;
				case ',':  return shift_down_ ? key_less : key_8;
				case '.':  return shift_down_ ? key_greater : key_9;
				case '/':  return shift_down_ ? key_question : key_0;
				case 'A':  return shift_down_ ? key_A : key_a;
				case 'B':  return shift_down_ ? key_B : key_b;
				case 'C':  return shift_down_ ? key_C : key_c;
				case 'D':  return shift_down_ ? key_D : key_d;
				case 'E':  return shift_down_ ? key_E : key_e;
				case 'F':  return shift_down_ ? key_F : key_f;
				case 'G':  return shift_down_ ? key_G : key_g;
				case 'H':  return shift_down_ ? key_H : key_h;
				case 'I':  return shift_down_ ? key_I : key_i;
				case 'J':  return shift_down_ ? key_J : key_j;
				case 'K':  return shift_down_ ? key_K : key_k;
				case 'L':  return shift_down_ ? key_L : key_l;
				case 'M':  return shift_down_ ? key_M : key_m;
				case 'N':  return shift_down_ ? key_N : key_n;
				case 'O':  return shift_down_ ? key_O : key_o;
				case 'P':  return shift_down_ ? key_P : key_p;
				case 'Q':  return shift_down_ ? key_Q : key_q;
				case 'R':  return shift_down_ ? key_R : key_r;
				case 'S':  return shift_down_ ? key_S : key_s;
				case 'T':  return shift_down_ ? key_T : key_t;
				case 'U':  return shift_down_ ? key_U : key_u;
				case 'V':  return shift_down_ ? key_V : key_v;
				case 'W':  return shift_down_ ? key_W : key_w;
				case 'X':  return shift_down_ ? key_X : key_x;
				case 'Y':  return shift_down_ ? key_Y : key_y;
				case 'Z':  return shift_down_ ? key_Z : key_z;
			}
			return key_other;
		}
	}
}

} // namespace _

#else

namespace _glx {

	static constexpr int GLX_USE_GL_            = 1;
	static constexpr int GLX_BUFFER_SIZE_       = 2;
	static constexpr int GLX_LEVEL_             = 3;   
	static constexpr int GLX_RGBA_              = 4;   
	static constexpr int GLX_DOUBLEBUFFER_      = 5;
	static constexpr int GLX_STEREO_            = 6;
	static constexpr int GLX_AUX_BUFFERS_       = 7;
	static constexpr int GLX_RED_SIZE_          = 8;
	static constexpr int GLX_GREEN_SIZE_        = 9;
	static constexpr int GLX_BLUE_SIZE_         = 10;
	static constexpr int GLX_ALPHA_SIZE_        = 11;
	static constexpr int GLX_DEPTH_SIZE_        = 12;
	static constexpr int GLX_STENCIL_SIZE_      = 13;
	static constexpr int GLX_ACCUM_RED_SIZE_    = 14;
	static constexpr int GLX_ACCUM_GREEN_SIZE_  = 15;
	static constexpr int GLX_ACCUM_BLUE_SIZE_   = 16;
	static constexpr int GLX_ACCUM_ALPHA_SIZE_  = 17;

	static constexpr int GLX_BAD_SCREEN_        = 1;
	static constexpr int GLX_BAD_ATTRIBUTE_     = 2;
	static constexpr int GLX_NO_EXTENSION_      = 3;
	static constexpr int GLX_BAD_VISUAL_        = 4;
	static constexpr int GLX_BAD_CONTEXT_       = 5;
	static constexpr int GLX_BAD_VALUE_         = 6;
	static constexpr int GLX_BAD_ENUM_          = 7;

	using Display     = ::Display;
	using XID         = size_t;
	using GLXContext  = struct GLXContext_ *;
	using GLXPixmap   = XID;
	using GLXDrawable = XID;

	using glx_proc_t = void (*)(void);
	extern "C" glx_proc_t    glXGetProcAddress(unsigned char const * proc_name);
	extern "C" XVisualInfo * glXChooseVisual(Display *dpy, int screen, int *attribList);
	extern "C" GLXContext    glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct);
	extern "C" void          glXDestroyContext(Display *dpy, GLXContext ctx);
	extern "C" Bool          glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ct);
	extern "C" void          glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask);
	extern "C" void          glXSwapBuffers(Display *dpy, GLXDrawable drawable);
	extern "C" GLXPixmap     glXCreateGLXPixmap(Display *dpy, XVisualInfo *visual, Pixmap pixmap);
	extern "C" void          glXDestroyGLXPixmap(Display *dpy, GLXPixmap pixmap);
	extern "C" Bool          glXQueryExtension(Display *dpy, int *errorb, int *event);
	extern "C" Bool          glXQueryVersion(Display *dpy, int *maj, int *min);
	extern "C" Bool          glXIsDirect(Display *dpy, GLXContext ctx);
	extern "C" int           glXGetConfig(Display *dpy, XVisualInfo *visual, int attrib, int *value);
	extern "C" GLXContext    glXGetCurrentContext();
	extern "C" GLXDrawable   glXGetCurrentDrawable();
	extern "C" void          glXWaitGL();
	extern "C" void          glXWaitX();
	extern "C" void          glXUseXFont(Font font, int first, int count, int list);

} // namespace _glx

namespace _ {

static constexpr key
_map_key(KeySym key_sym_)
{
	switch(key_sym_)
	{
		case XK_Cancel:        return key_cancel;
		case XK_BackSpace:     return key_backspace;
		case XK_Tab:           return key_tab;
		case XK_Clear:         return key_clear;
		case XK_Return:        return key_enter;
		case XK_Shift_L:       return key_lshift;
		case XK_Shift_R:       return key_rshift;
		case XK_Control_L:     return key_lcontrol;
		case XK_Control_R:     return key_rcontrol;
		case XK_Alt_L:         return key_lalt;
		case XK_Alt_R:         return key_ralt;
		case XK_Menu:          return key_menu;
		case XK_Super_L:       return key_lcommand;
		case XK_Super_R:       return key_rcommand;
		case XK_Pause:         return key_pause;
		case XK_Num_Lock:      return key_num_lock;
		case XK_Caps_Lock:     return key_caps_lock;
		case XK_Scroll_Lock:   return key_scroll_lock;
		case XK_Escape:        return key_escape;
		case XK_space:         return key_space;
		case XK_Prior:         return key_page_up;
		case XK_Next:          return key_page_down;
		case XK_End:           return key_end;
		case XK_Home:          return key_home;
		case XK_Left:          return key_left;
		case XK_Right:         return key_right;
		case XK_Up:            return key_up;
		case XK_Down:          return key_down;
		case XK_Select:        return key_select;
		case XK_Execute:       return key_execute;
		case XK_Print:         return key_print;
		case XK_Insert:        return key_insert;
		case XK_Delete:        return key_delete;
		case XK_Help:          return key_help;
		case XK_F1:            return key_f1;
		case XK_F2:            return key_f2;
		case XK_F3:            return key_f3;
		case XK_F4:            return key_f4;
		case XK_F5:            return key_f5;
		case XK_F6:            return key_f6;
		case XK_F7:            return key_f7;
		case XK_F8:            return key_f8;
		case XK_F9:            return key_f9;
		case XK_F10:           return key_f10;
		case XK_F11:           return key_f11;
		case XK_F12:           return key_f12;
		case XK_1:             return key_1;
		case XK_2:             return key_2;
		case XK_3:             return key_3;
		case XK_4:             return key_4;
		case XK_5:             return key_5;
		case XK_6:             return key_6;
		case XK_7:             return key_7;
		case XK_8:             return key_8;
		case XK_9:             return key_9;
		case XK_0:             return key_0;
		case XK_quoteleft:     return key_back_tick;
		case XK_asciitilde:    return key_tilde;
		case XK_exclam:        return key_exclamation;
		case XK_at:            return key_at;
		case XK_numbersign:    return key_numbersign;
		case XK_dollar:        return key_dollarsign;
		case XK_percent:       return key_percent;
		case XK_asciicircum:   return key_circumflex;
		case XK_ampersand:     return key_ampersand;
		case XK_asterisk:      return key_asterisk;
		case XK_parenleft:     return key_lparenthesis;
		case XK_parenright:    return key_rparenthesis;
		case XK_minus:         return key_minus;
		case XK_underscore:    return key_underscore;
		case XK_equal:         return key_equal;
		case XK_plus:          return key_plus;
		case XK_bracketleft:   return key_lbracket;
		case XK_braceleft:     return key_lbrace;
		case XK_bracketright:  return key_rbracket;
		case XK_braceright:    return key_rbrace;
		case XK_backslash:     return key_back_slash;
		case XK_bar:           return key_bar;
		case XK_semicolon:     return key_semicolon;
		case XK_colon:         return key_colon;
		case XK_quoteright:    return key_quote;
		case XK_quotedbl:      return key_double_quote;
		case XK_comma:         return key_comma;
		case XK_less:          return key_less;
		case XK_period:        return key_period;
		case XK_greater:       return key_greater;
		case XK_slash:         return key_slash;
		case XK_question:      return key_question;
		case XK_a:             return key_a;
		case XK_b:             return key_b;
		case XK_c:             return key_c;
		case XK_d:             return key_d;
		case XK_e:             return key_e;
		case XK_f:             return key_f;
		case XK_g:             return key_g;
		case XK_h:             return key_h;
		case XK_i:             return key_i;
		case XK_j:             return key_j;
		case XK_k:             return key_k;
		case XK_l:             return key_l;
		case XK_m:             return key_m;
		case XK_n:             return key_n;
		case XK_o:             return key_o;
		case XK_p:             return key_p;
		case XK_q:             return key_q;
		case XK_r:             return key_r;
		case XK_s:             return key_s;
		case XK_t:             return key_t;
		case XK_u:             return key_u;
		case XK_v:             return key_v;
		case XK_w:             return key_w;
		case XK_x:             return key_x;
		case XK_y:             return key_y;
		case XK_z:             return key_z;
		case XK_KP_0:          return key_num_0;
		case XK_KP_1:          return key_num_1;
		case XK_KP_2:          return key_num_2;
		case XK_KP_3:          return key_num_3;
		case XK_KP_4:          return key_num_4;
		case XK_KP_5:          return key_num_5;
		case XK_KP_6:          return key_num_6;
		case XK_KP_7:          return key_num_7;
		case XK_KP_8:          return key_num_8;
		case XK_KP_9:          return key_num_9;
		case XK_KP_Divide:     return key_num_divide;
		case XK_KP_Multiply:   return key_num_multiply;
		case XK_KP_Subtract:   return key_num_subtract;
		case XK_KP_Add:        return key_num_add;
		case XK_KP_Enter:      return key_num_enter;
		case XK_KP_Decimal:    return key_num_decimal;
		case XK_KP_Delete:     return key_num_delete;
		case XK_KP_Insert:     return key_num_insert;
		case XK_KP_Home:       return key_num_home;
		case XK_KP_End:        return key_num_end;
		case XK_KP_Page_Up:    return key_num_page_up;
		case XK_KP_Page_Down:  return key_num_page_down;
		case XK_KP_Left:       return key_num_left;
		case XK_KP_Right:      return key_num_right;
		case XK_KP_Up:         return key_num_up;
		case XK_KP_Down:       return key_num_down;
		default:               return key_other;
	}
}

} // namespace _


#endif

struct create_window_failure : public ds::exception
{
	char const *
	what() const noexcept override
	{
		return "create window failure";
	}
};

struct create_context_failure : public ds::exception
{
	char const *
	what() const noexcept override
	{
		return "create context failure";
	}
};

struct invalid_window : public ds::exception
{
	char const *
	what() const noexcept override
	{
		return "invalid window";
	}
};


class Window
{
	Display    * _display    = nullptr;
	ds::string<> _title;
	int          _x          = 0;
	int          _y          = 0;
	int          _width      = 0;
	int          _height     = 0;
	bool         _destroying = false;
  #ifdef _WIN32
	using LRESULT   = _win::LRESULT;
	using HINSTANCE = _win::HINSTANCE;
	using HWND      = _win::HWND;
	using HDC       = _win::HDC;
	using HGLRC     = _win::HGLRC;
	using UINT      = _win::UINT;
	using WPARAM    = _win::WPARAM;
	using LPARAM    = _win::LPARAM;
	using DWORD     = _win::DWORD;
	static constexpr HINSTANCE _null_winhinst  = NULL;
	static constexpr HWND      _null_winwindow = NULL;
	static constexpr HDC       _null_windevctx = NULL;
	static constexpr HGLRC     _null_winglctx  = NULL;
	HINSTANCE _winhinst  = _null_winhinst;
	HWND      _winwindow = _null_winwindow;
	HDC       _windevctx = _null_windevctx;
	HGLRC     _winglctx  = _null_winglctx;
	DWORD     _style     = 0;
  #else
	static constexpr ::Window _null_xwindow = {};
	::Window           _xwindow    = _null_xwindow;
	_glx::GLXContext   _xcontext   = nullptr;
	bool               _raised     = false;
  #endif

#ifdef _WIN32
	static LRESULT __stdcall 
	_win_proc(HWND hwnd, UINT umsg, WPARAM wparam, LPARAM lparam)
	{
		using namespace mw::_win;
		auto * window = reinterpret_cast<Window *>(GetWindowLongPtrA(hwnd, GWLP_USERDATA_));
		if(window != nullptr)
		{
			switch(umsg)
			{
				case WM_DESTROY_:
				{
					if(!window->_destroying)
						window->destroy();
					return 0;
				}
				case WM_SIZE_:
				{
					switch(wparam) 
					{
						case SIZE_MAXHIDE_:
						case SIZE_MINIMIZED_: 
							break;
						case SIZE_MAXIMIZED_:
						case SIZE_MAXSHOW_:
						case SIZE_RESTORED_:
						default:
						{
							int width  = _loword(DWORD(lparam));
							int height = _hiword(DWORD(lparam));
							window->_on_size(width, height);
							return 0;
						}
					}
					break;
				}
				case WM_MOVE_:
				{
					int    x_    = _loword(DWORD(lparam));
					int    y_    = _hiword(DWORD(lparam));
					window->_on_move(x_, y_);
					return 0;
				}
				case WM_LBUTTONDOWN_:
				case WM_LBUTTONUP_:
				case WM_NCLBUTTONUP_:
				{
					int    x_    = _loword(DWORD(lparam));
					int    y_    = _hiword(DWORD(lparam));
					bool   down_ = umsg == WM_LBUTTONDOWN_;
					window->_on_mouse_button(x_, y_, mb_left, down_);
					return 0;
				}
				case WM_RBUTTONDOWN_:
				case WM_RBUTTONUP_:
				case WM_NCRBUTTONUP_:
				{
					int    x_    = _loword(DWORD(lparam));
					int    y_    = _hiword(DWORD(lparam));
					bool   down_ = umsg == WM_RBUTTONDOWN_;
					window->_on_mouse_button(x_, y_, mb_right, down_);
					return 0;
				}
				case WM_MBUTTONDOWN_:
				case WM_MBUTTONUP_:
				case WM_NCMBUTTONUP_:
				{
					int    x_    = _loword(DWORD(lparam));
					int    y_    = _hiword(DWORD(lparam));
					bool   down_ = umsg == WM_MBUTTONDOWN_;
					window->_on_mouse_button(x_, y_, mb_middle, down_);
					return 0;
				}
				case WM_XBUTTONDOWN_:
				case WM_XBUTTONUP_:
				{
					int    x_    = _loword(DWORD(lparam));
					int    y_    = _hiword(DWORD(lparam));
					bool   down_ = umsg == WM_XBUTTONDOWN_;
					short  xn_   = _hiword(DWORD(wparam));
					switch(xn_)
					{
						case 1:  window->_on_mouse_button(x_, y_, mb_extra1, down_); break;
						case 2:  window->_on_mouse_button(x_, y_, mb_extra2, down_); break;
						default: window->_on_mouse_button(x_, y_, mb_other,  down_); break;
					}
					return 0;
				}
				case WM_MOUSEMOVE_:
				{
					int x_ = _loword(DWORD(lparam));
					int y_ = _hiword(DWORD(lparam));
					window->_on_mouse_move(x_, y_);
					return 0;
				}
				case WM_MOUSEWHEEL_:
				case WM_MOUSEHWHEEL_:
				{
					bool  vertical_ = umsg == WM_MOUSEWHEEL_;
					int   delta_    = _hiword(DWORD(wparam));
					POINT point_    = { _loword(DWORD(lparam)), _hiword(DWORD(lparam)) };
					ScreenToClient(hwnd, &point_);
					window->_on_mouse_wheel(point_.x, point_.y, delta_, vertical_);
					return 0;
				}
				case WM_KEYDOWN_:
				case WM_KEYUP_:
				{
					UINT scancode_ = (lparam & 0x00ff0000) >> 16;
					int  extended_ = (lparam & 0x01000000) != 0;
					bool down_ = umsg == WM_KEYDOWN_;
					key  key_  = key_other;
					switch(wparam)
					{
						case VK_CONTROL_:
							key_ = _::_map_key(DWORD(extended_ ? VK_RCONTROL_ : VK_LCONTROL_));
							break;
						case VK_SHIFT_:
							key_ = _::_map_key(DWORD(MapVirtualKeyA(scancode_, MAPVK_VSC_TO_VK_EX_)));
							break;
						default:
							key_ = _::_map_key(DWORD(wparam), DWORD(lparam));
							break;
					}
					window->_on_key(key_, down_);
					return 0;
				}
				case WM_SYSKEYDOWN_:
				case WM_SYSKEYUP_:
				{
					int  extended_ = (lparam & 0x01000000) != 0;
					bool down_ = umsg == WM_SYSKEYDOWN_;
					key  key_  = key_other;
					switch(wparam)
					{
						case VK_MENU_:
							key_ = _::_map_key(DWORD(extended_ ? VK_RMENU_ : VK_LMENU_));
							break;
						case VK_LWIN_:
						case VK_RWIN_:
							key_ = _::_map_key(DWORD(wparam));
							break;
						default:
							return DefWindowProcA(hwnd, umsg, wparam, lparam);
					}
					window->_on_key(key_, down_);
					return DefWindowProcA(hwnd, umsg, wparam, lparam);
				}
			}
		}
		return DefWindowProcA(hwnd, umsg, wparam, lparam);
	};

#else
	static ds::unordered_map<32,::Window,Window *> _map;
	
	bool
	_is_destroying() noexcept
	{
		return _destroying;
	}
	
	void
	_handle_xevent(::XEvent & xevent_) noexcept 
	{
		switch(xevent_.type)
		{
			case DestroyNotify:
			case ClientMessage:
			{
				if(!_destroying)
					this->destroy();
				break;
			}
			case ConfigureNotify:
			{
				int x_ = xevent_.xconfigure.x;
				int y_ = xevent_.xconfigure.y;
				int width_  = xevent_.xconfigure.width;
				int height_ = xevent_.xconfigure.height;
				if(width_ != _width || height_ != _height)
					this->_on_size(width_, height_);
				if(x_ != _x || y_ != _y)
					this->_on_move(x_, y_);
				break;
			}
			case ButtonPress:
			case ButtonRelease:
			{
				int  x_  = xevent_.xbutton.x;
				int  y_  = xevent_.xbutton.y;
				switch(xevent_.xbutton.button)
				{
					case Button1: this->_on_mouse_button(x_, y_, mb_left,   xevent_.type == ButtonPress); break;
					case Button2: this->_on_mouse_button(x_, y_, mb_middle, xevent_.type == ButtonPress); break;
					case Button3: this->_on_mouse_button(x_, y_, mb_right,  xevent_.type == ButtonPress); break;
					case Button4: this->_on_mouse_wheel(x_, y_,  120, true); break;
					case Button5: this->_on_mouse_wheel(x_, y_, -120, true); break;
					case Button5+1: this->_on_mouse_button(x_, y_, mb_extra1, xevent_.type == ButtonPress); break;
					case Button5+2: this->_on_mouse_button(x_, y_, mb_extra2, xevent_.type == ButtonPress); break;
					default:        this->_on_mouse_button(x_, y_, mb_other,  xevent_.type == ButtonPress); break;
				}
				break;
			}
			case MotionNotify:
			{
				int  x_  = xevent_.xmotion.x;
				int  y_  = xevent_.xmotion.y;
				this->_on_mouse_move(x_, y_);
				break;
			}
			case KeyPress:
			case KeyRelease:
			{
				bool     down_     = xevent_.type == KeyPress;
				int      state_    = xevent_.xkey.state;
				key      key_      = _::_map_key(XLookupKeysym(&xevent_.xkey, (state_ & Mod2Mask ? 1 : 0)));
				this->_on_key(key_, down_);
				break;
			}
		}
	}

#endif

	friend bool process_event(Event & event) noexcept(false);

	void 
	_on_move(int x_, int y_) noexcept
	{
		_x  = x_;
		_y = y_;
		if(on_move)
			on_move(_x, _y);
	}

	void 
	_on_size(int width_, int height_) noexcept
	{
		_width  = width_;
		_height = height_;
		if(on_size)
			on_size(_width, _height);
	}

	void
	_on_mouse_button(int x_, int y_, mouse_button button_, bool down_) noexcept
	{
		if(on_mouse_button)
			on_mouse_button(x_, y_, button_, down_);
	}

	void
	_on_mouse_move(int x_, int y_) noexcept
	{
		if(on_mouse_move)
			on_mouse_move(x_, y_);
	}

	void
	_on_mouse_wheel(int x_, int y_, int delta_, bool vertical_) noexcept
	{
		if(on_mouse_wheel)
			on_mouse_wheel(x_, y_, delta_, vertical_);
	}

	void
	_on_key(key key_, bool down_) noexcept
	{
		if(on_key)
			on_key(key_, down_);
	}

 public:
	ds::callable<void(int,int)> on_move;
	ds::callable<void(int,int)> on_size;
	ds::callable<void(int,int,mouse_button,bool)> on_mouse_button;
	ds::callable<void(int,int)>                   on_mouse_move;
	ds::callable<void(int,int,int,bool)>          on_mouse_wheel;
	ds::callable<void(key,bool)> on_key;

 public:
	~Window() noexcept
	{
		this->destroy();
	}

	Window(Display & display_, ds::string<> title_, int width_, int height_) noexcept(false)
		: _display { &display_ }
		, _title   { ds::move(title_) }
  #ifdef _WIN32
	{
		constexpr char const * CLASS_NAME = "MPW_WINDOW";
		using namespace mw::_win;
		auto hinst = (HINSTANCE)GetModuleHandleA(nullptr);
		_winhinst  = hinst;
		assert(hinst != NULL);
		static bool _registered = false;
		if(!_registered)
		{
			WNDCLASSEXA wcex {};
			wcex.cbSize        = sizeof(WNDCLASSEXA);
			wcex.hInstance     = hinst;
			wcex.style         = CS_OWNDC_;
			wcex.hbrBackground = (HBRUSH)(size_t(COLOR_WINDOW_));
			wcex.hCursor       = LoadCursorA(NULL, reinterpret_cast<char const *>(IDC_ARROW_));
			wcex.hIcon         = LoadIconA(NULL,   reinterpret_cast<char const *>(IDI_APPLICATION_));
			wcex.lpfnWndProc   = _win_proc;
			wcex.lpszClassName = CLASS_NAME;
			auto res = RegisterClassExA(&wcex);
			assert(res != NULL);
			_registered = res != NULL;
		}
		_style = WS_OVERLAPPEDWINDOW_;
		RECT rc { 0, 0, width_, height_ };
		AdjustWindowRectEx(&rc, _style, 0, 0);
		HWND hwnd = CreateWindowExA(0, CLASS_NAME, _title.begin()
			, _style
			, CW_USEDEFAULT_, CW_USEDEFAULT_, (rc.right - rc.left), (rc.bottom - rc.top)
			, NULL, NULL, hinst, nullptr);
		_winwindow = hwnd;
		ds_throw_if(hwnd == _null_winwindow, create_window_failure());
		ds_throw_if_alt(hwnd == _null_winwindow, assert(hwnd != _null_winwindow); return);
		SetWindowLongPtrA(hwnd, GWLP_USERDATA_, LONG_PTR(this));
		auto * window = reinterpret_cast<Window *>(GetWindowLongPtrA(hwnd, GWLP_USERDATA_));
		ds_throw_if(window != this, create_window_failure());
		ds_throw_if_alt(window != this, assert(window == this); return);
		HDC hdc = GetDC(hwnd);
		_windevctx = hdc;
		{
			PIXELFORMATDESCRIPTOR pfd {};
			pfd.nSize        = sizeof(PIXELFORMATDESCRIPTOR);
			pfd.nVersion     = 1;
			pfd.iPixelType   = PFD_TYPE_RGBA_;
			pfd.dwFlags      = PFD_DRAW_TO_WINDOW_ | PFD_SUPPORT_OPENGL_ | PFD_DOUBLEBUFFER_ | PFD_SWAP_EXCHANGE_;
			pfd.iLayerType   = PFD_MAIN_PLANE_;
			pfd.cColorBits   = 32;
			pfd.cDepthBits   = 24;
			pfd.cStencilBits = 8;
			SetPixelFormat(hdc, ChoosePixelFormat(hdc, &pfd), &pfd);
		}
		HGLRC hglrc = wglCreateContext(hdc);
		_winglctx   = hglrc;
		ds_throw_if(_winglctx == _null_winglctx, create_context_failure());
		ds_throw_if_alt(_winglctx == _null_winglctx, assert(_winglctx != _null_winglctx); return);
		wglMakeCurrent(_windevctx, _winglctx);
	}
  #else
	{
		ds_throw_if(display_._xdisplay == nullptr, invalid_display());
		ds_throw_if_alt(display_._xdisplay == nullptr, assert(display_._xdisplay != nullptr); return);
		using namespace mw::_glx;
		int attributes_[] = { GLX_RGBA_, GLX_DEPTH_SIZE_, 24, GLX_DOUBLEBUFFER_, None };
		auto * xdisplay_  = display_._xdisplay;
		auto * visual_    = glXChooseVisual(xdisplay_, 0, attributes_);
		ds_throw_if(visual_ == nullptr, create_window_failure());
		ds_throw_if_alt(visual_ == nullptr, assert(visual_ != nullptr); return);
		{
			XSetWindowAttributes swa;
			auto root_     = DefaultRootWindow(xdisplay_);
			auto screen    = DefaultScreen(xdisplay_);
			swa.colormap   = XCreateColormap(xdisplay_, root_, visual_->visual, AllocNone);
			swa.event_mask = Expose | StructureNotifyMask | VisibilityChangeMask | ClientMessage
			               | ButtonPressMask | ButtonReleaseMask | PointerMotionMask 
			               | KeyPressMask | KeyReleaseMask;
			swa.background_pixel = XWhitePixel(xdisplay_, screen);
			swa.border_pixel     = XBlackPixel(xdisplay_, screen);
			// swa.override_redirect  = True;
			unsigned long swa_mask = CWColormap | CWEventMask | CWBackPixel | CWBorderPixel; 
			// swa_mask |= CWOverrideRedirect;
			_xwindow   = XCreateWindow(xdisplay_, root_, 0, 0, width_, height_, 0, visual_->depth
									, InputOutput, visual_->visual, swa_mask, &swa);
			ds_throw_if(_xwindow == _null_xwindow, create_window_failure());
			ds_throw_if_alt(_xwindow == _null_xwindow, assert(_xwindow != _null_xwindow); return);
			auto window_closed_ = XInternAtom(xdisplay_, "WM_DELETE_WINDOW", True);
			XSetWMProtocols(xdisplay_, _xwindow, &window_closed_, 1);
			XStoreName(xdisplay_, _xwindow, _title.begin());
			XClearWindow(xdisplay_, _xwindow);
		}
		{
			_xcontext = glXCreateContext(xdisplay_, visual_, nullptr, 1);
			ds_throw_if(_xcontext == nullptr, create_context_failure());
			ds_throw_if_alt(_xcontext == nullptr, assert(_xcontext != nullptr));
			glXMakeCurrent(xdisplay_, _xwindow, _xcontext);
		}
		_map.set(_xwindow, this);
	}
  #endif
	
	void 
	destroy() noexcept
	{
	  #ifdef _WIN32
		if(_winwindow != _null_winwindow)
		{
			using namespace mw::_win;
			_destroying = true;
			if(_winglctx != _null_winglctx)
			{
				wglMakeCurrent(_null_windevctx, _null_winglctx);
				wglDeleteContext(_winglctx);
			}
			if(_windevctx != _null_windevctx)
			{
				ReleaseDC(_winwindow, _windevctx);
			}
			DestroyWindow(_winwindow);
			_destroying = false;
			_winwindow = _null_winwindow;
		}
	  #else
		auto display_valid_ = _display != nullptr && _display->_xdisplay != nullptr;
		if(_xcontext != nullptr)
		{
			if(display_valid_)
			{
				using namespace mw::_glx;
				glXMakeCurrent(_display->_xdisplay, None, nullptr);
				glXDestroyContext(_display->_xdisplay, _xcontext);
			}
			_xcontext = nullptr;
		}
	  	if(_xwindow != _null_xwindow)
		{
			if(display_valid_)
			{
				_destroying = true;
				XDestroyWindow(_display->_xdisplay, _xwindow);
				_destroying = false;
			}
			_map.remove(_xwindow);
			_xwindow = _null_xwindow;
		}
	  #endif
	}

	bool
	show() noexcept(false)
	{
	  #ifdef _WIN32
		ds_throw_if(_winwindow == _null_winwindow, invalid_window());
		ds_throw_if_alt(_winwindow == _null_winwindow, assert(_winwindow != _null_winwindow); return false);
		using namespace mw::_win;
		ShowWindow(_winwindow, SW_NORMAL_);
		return true;
	  #else
		ds_throw_if(_display == nullptr || _display->_xdisplay == nullptr, invalid_display());
		ds_throw_if_alt(_display == nullptr || _display->_xdisplay == nullptr, assert(_display != nullptr && _display._xdisplay != nullptr); return false);
		ds_throw_if(_xwindow == _null_xwindow, invalid_window());
		ds_throw_if_alt(_xwindow == _null_xwindow, assert(_xwindow != _null_xwindow); return false);
		if(XMapRaised(_display->_xdisplay, _xwindow) != False)
		{
			_raised = true;
			return true;
		}
	  #endif
		return false;
	}

	bool
	enable_vsync(bool sync = true) noexcept(false)
	{
	  #ifdef __WIN32
	  #else
		ds_throw_if(_display == nullptr || _display->_xdisplay == nullptr, invalid_display());
		ds_throw_if_alt(_display == nullptr || _display->_xdisplay == nullptr, assert(_display != nullptr && _display._xdisplay != nullptr); return false);
		ds_throw_if(_xwindow == _null_xwindow, invalid_window());
		ds_throw_if_alt(_xwindow == _null_xwindow, assert(_xwindow != _null_xwindow); return false);
		using namespace mw::_glx;
		using glxSwapIntervalEXT_t = void(*)(::Display *, GLXDrawable, int);
		static glxSwapIntervalEXT_t glxSwapIntervalEXT = reinterpret_cast<glxSwapIntervalEXT_t>(glXGetProcAddress((unsigned char const *)"glxSwapIntervalEXT"));
		if(glxSwapIntervalEXT != nullptr)
		{
			glxSwapIntervalEXT(_display->_xdisplay, _xwindow, int(sync));
			return true;
		}
	  #endif
		return false;
	}

	void
	swap()
	{
	  #ifdef _WIN32
		ds_throw_if(_winwindow == _null_winwindow, invalid_window());
		ds_throw_if_alt(_winwindow == _null_winwindow, assert(_winwindow != _null_winwindow); return);
		using namespace mw::_win;
		SwapBuffers(_windevctx);
	  #else
		ds_throw_if(_display == nullptr || _display->_xdisplay == nullptr, invalid_display());
		ds_throw_if_alt(_display == nullptr || _display->_xdisplay == nullptr, assert(_display != nullptr && _display._xdisplay != nullptr); return false);
		ds_throw_if(_xwindow == _null_xwindow, invalid_window());
		ds_throw_if_alt(_xwindow == _null_xwindow, assert(_xwindow != _null_xwindow); return false);
		using namespace mw::_glx;
		if(_display != nullptr && _display->_xdisplay != nullptr)
			glXSwapBuffers(_display->_xdisplay, _xwindow);
	  #endif
	}

	bool
	make_current() noexcept
	{
	  #ifdef _WIN32
		using namespace mw::_win;
		if(_winwindow != _null_winwindow && _winglctx != _null_winglctx)
		{
			if(wglGetCurrentContext() == _winglctx)
				return true;
			return wglMakeCurrent(_windevctx, _winglctx) != 0;
		}
	  #else
		using namespace mw::_glx;
		if(_display != nullptr && _display->_xdisplay != nullptr && _xwindow != _null_xwindow)
		{
			if(glXGetCurrentContext() == _xcontext)
				return true;
			else
				return glXMakeCurrent(_display->_xdisplay, _xwindow, _xcontext) != False;
		}
	  #endif
		return false;
	}

	bool 
	set_position(int x_, int y_) noexcept
	{
	  #ifdef _WIN32
		using namespace mw::_win;
		if(_winwindow != _null_winwindow)
			return SetWindowPos(_winwindow, _null_winwindow, x_, y_, 0, 0, SWP_NOSIZE_) != 0;
	  #else
		if(_display != nullptr && _display->_xdisplay != nullptr && _xwindow != _null_xwindow)
			return XMoveWindow(_display->_xdisplay, _xwindow, x_, y_) == 0;
	  #endif
		return false;
	}

	bool 
	set_size(int width_, int height_) noexcept
	{
	  #ifdef _WIN32
		using namespace mw::_win;
		if(_winwindow != _null_winwindow)
			return SetWindowPos(_winwindow, _null_winwindow, 0, 0, width_, height_, SWP_NOMOVE_) != 0;
	  #else
		if(_display != nullptr && _display->_xdisplay != nullptr && _xwindow != _null_xwindow)
			return XResizeWindow(_display->_xdisplay, _xwindow, width_, height_) == 0;
	  #endif
		return false;
	}

	int width()  const noexcept { return _width; }
	int height() const noexcept { return _height; }

  #ifdef _WIN32
	bool operator!() noexcept { return _winwindow == _null_winwindow; }
	explicit operator bool()       noexcept { return _winwindow != _null_winwindow; }
	explicit operator bool() const noexcept { return _winwindow != _null_winwindow; }
  #else
	bool operator!() noexcept { return _xwindow == _null_xwindow; }
	explicit operator bool()       noexcept { return _xwindow != _null_xwindow; }
	explicit operator bool() const noexcept { return _xwindow != _null_xwindow; }
  #endif

};

#ifndef _WIN32
ds::unordered_map<32,::Window,Window *> Window::_map;
#endif

using window = Window;

} // namespace mw


#endif // MPW_WINDOW
